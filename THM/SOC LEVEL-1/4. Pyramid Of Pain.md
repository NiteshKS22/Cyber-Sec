## Task 2: Hash Values (Trivial) â€” The Digital Fingerprint

### Defining Identity
How do I know a file is safe? I can't look at it and see if it's "evil." In the digital world, we identify files using **Hash Values**.

A hash is a numeric value of a fixed length that uniquely identifies data. Think of it as a digital fingerprint. If I download a file, calculate its hash, and it matches the known "good" hash, I know the file hasn't been tampered with.

### The Evolution of Algorithms
Not all fingerprints are created equal. I learned about the history of these algorithms and how some have "aged out" of security.

| Algorithm | Born | Status | My Take |
| :--- | :--- | :--- | :--- |
| **MD5** (Message Digest 5) | 1992 | **BROKEN** ðŸš« | The grandfather. It produces a 128-bit hash. It is **not** cryptographically secure anymore because of "collisions" (two different files can have the same MD5 hash). |
| **SHA-1** (Secure Hash Algorithm 1) | 1995 | **BANNED** ðŸš« | The retired veteran. Created by the NSA. It produces a 160-bit hash. NIST banned it in 2013 because it is susceptible to brute-force attacks. |
| **SHA-256** (Secure Hash Algorithm 2) | 2001 | **STANDARD** âœ… | The current reliable choice. Also NSA/NIST designed. It produces a massive 256-bit hash. This is what we use today. |

### The Detective Tools
Security professionals use hashes to identify malware. When I find a suspicious file, I don't run it. I take its hash and check it against global databases.

Two tools I use constantly:
1.  **VirusTotal:** I paste the hash, and it tells me if other antivirus engines have flagged it.
2.  **MetaDefender Cloud (OPSWAT):** Similar to VirusTotal, excellent for cross-referencing.

*Reference:* If you read reports from **The DFIR Report** or **Trellix**, they always list the hashes of the malware at the end. These are our "Indicators of Compromise" (IOCs).



### The "Trivial" Problem (Why Hashes Aren't Enough)
This task is called "Trivial" for a reason. While hashes are great for identifying *known* malware, they are terrible at catching *modified* malware.

**The Fragility of a Hash:**
If an attacker changes **one single bit** of a file, the entire hash changes completely.

I tested this in PowerShell to see it with my own eyes. I took a legitimate installer (`OpenVPN`) and simply added a text string to the end of it.

**1. The Original File**
```powershell
PS C:\Users\THM\Downloads> Get-FileHash .\OpenVPN_2.5.1_I601_amd64.msi -Algorithm MD5

Algorithm Hash                             Path                                                 
_________ ____                             ____                                                 
MD5       D1A008E3A606F24590A02B853E955CF7 C:\Users\THM\Downloads\OpenVPN_2.5.1...

```

### 2. The Modification (The "Hack") I used echo to append a random string to the file.
```
PS C:\Users\THM\Downloads> echo "AppendTheHash" >> .\OpenVPN_2.5.1_I601_amd64.msi
```

### 3. The Result

```
PS C:\Users\THM\Downloads> Get-FileHash .\OpenVPN_2.5.1_I601_amd64.msi -Algorithm MD5

Algorithm Hash                             Path                                                 
_________ ____                             ____                                                 
MD5       9D52B46F5DE41B73418F8E0DACEC5E9F C:\Users\THM\Downloads\OpenVPN_2.5.1...
```

**Conclusion: The file still works, but the hash is totally different (D1A0... vs 9D52...). This is why hunting by file hash alone is difficultâ€”attackers can change their "fingerprints" trivially.